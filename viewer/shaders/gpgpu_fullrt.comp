#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;
uniform bool noColor;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

bool intersectBoundingBox(vec4 origin, vec4 dir) {
	vec3 tmin_tmp = (bbmin - origin.xyz) / dir.xyz;
	vec3 tmax_tmp = (bbmax - origin.xyz) / dir.xyz;
    
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);

    float t_in  = max(max(tmin.x, tmin.y), tmin.z);
    float t_out = min(min(tmax.x, tmax.y), tmax.z);

    return t_out > 0 && t_out > t_in; // t_out > 0 condition to intersect if inside the AABB but not behind it.
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist) 
{
	vec3 v0 = vertices[indices[ptr    ]].xyz;
	vec3 v1 = vertices[indices[ptr + 1]].xyz;
	vec3 v2 = vertices[indices[ptr + 2]].xyz;

    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;

    vec3 t = origin.xyz - v0;
    vec3 q = cross(t, e1);
    vec3 p = cross(dir.xyz, e2);

    vec3 res = (1 / dot(p, e1)) * vec3(dot(q, e2), dot(p, t), dot(q, dir.xyz));

    dist = vec4(res, 1 - res.y - res.z);
    return res.x > 0 && res.y >= 0 && res.z >= 0 && res.y+res.z <= 1; // There is an intersection if the point is inside the triangle and if the intersection is in front of us.
}

vec4 interpolateNormal(hitinfo_t h)
{
	vec4 n1 = normals[indices[h.hit_vptr    ]];
	vec4 n2 = normals[indices[h.hit_vptr + 1]];
	vec4 n3 = normals[indices[h.hit_vptr + 2]];

    float c = h.t.w;
    float alpha = h.t.y;
    float beta = h.t.z;

	return normalize(n1*c + n2*alpha + n3*beta);
}

vec4 interpolateColor(hitinfo_t h)
{
	vec4 c1 = colors[indices[h.hit_vptr    ]];
	vec4 c2 = colors[indices[h.hit_vptr + 1]];
	vec4 c3 = colors[indices[h.hit_vptr + 2]];

    float c = h.t.w;
    float alpha = h.t.y;
    float beta = h.t.z;

	return c1*c + c2*alpha + c3*beta;
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
                hit = true;
                if(dist.x < h.t.x) {
                    h.t = dist;
                    h.hit_vptr = j;
                }
			}
		}
	}
	return hit;
}

// Function that return true if the ray intersect with a triangle different from the self triangle.
// For the intersection to be registered, 
// the dot product between the normal of the intersecting face and the direction to the light need to be above an arbitrary threshold (0.2).
// In other words, the intersection is ignored if the normal is too perpendicular to the direction to the light.
// This is an arbitrary trick done to mitigate issues at the transition between direct/indirect light (see leaky_light.png).
// Note that this trick is not a real solution to the problem but, for the tested example, lead to better visual results.
bool isIntersectedNotSelfLeaky(vec4 origin, vec4 dir, int self, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(j != self && intersectTriangle(origin, dir, j, dist)) {
                hitinfo_t tmp;
                tmp.t = dist;
                tmp.hit_vptr = j;
                if (abs(dot(dir, interpolateNormal(tmp))) > 0.2) {
                hit = true;
                if(dist.x < h.t.x) {
                    h.t = dist;
                    h.hit_vptr = j;
                }
			}
		}
	}
	}
	return hit;
}

const int MAX_TRACE = 1;


bool directLight(vec4 dir_towards_light, vec4 oriented_normal, vec4 intersection, hitinfo_t h) {
    
    // If the direction toward the light is behind the hemisphere of the oriented normal then it's not directly illuminated
    // This prevent, for example, the inside of the mesh to be illuminated (particularly visible in the teapot model where light can leak behind the model due to the holes between the lid and the pot (see the hemisphere_fix.png image for visual explanation))
    if (dot(oriented_normal, dir_towards_light) < 0.0) {
        return false;
    }

    hitinfo_t hitinfo_light;
    // Send ray towards light source
    if(isIntersectedNotSelfLeaky(intersection, dir_towards_light, h.hit_vptr, hitinfo_light)) {
        // If intersection with a triangle between the point and the light source
        // Then no direct light
        return false;
    } else {
        // If nothing between point and light source, then direct light
        return true;
    }
}

// From TP1
vec4 getAmbiant(float k, vec4 C, float I) {
    return k * C * I;
}

// From TP1
vec4 getDiffuse(float k, vec4 C, float I, vec4 n, vec4 L) {
     return k * C * max(dot(n, L), 0.0) * I;
}

vec4 trace(vec4 origin, vec4 dir)
{
    // If intersection with the bounding box
    if (intersectBoundingBox(origin, dir)) {
        hitinfo_t hitinfo;
        // If intersection with a triangle within the bounding box
        if (isIntersected(origin, dir, hitinfo)) {
            vec4 C;
            if (noColor) {
                C = vec4(0.2, 0.6, 0.7, 1.0);
            } else {
                C = interpolateColor(hitinfo);
            }

            // Ambiant 
            float kA = 0.2;
            vec4 ambiant = getAmbiant(kA, C, lightIntensity);
            
            vec4 intersection = origin + hitinfo.t.x * dir;
            vec4 dir_towards_light = normalize(vec4(lightPosition, 1.0) - intersection); 
    
            // Normal of the intersected triangle 
            vec4 normal = interpolateNormal(hitinfo);
            // Oriented normal depending on the ray direction
            vec4 oriented_normal = normal * sign(dot(-dir, normal));
            
            if (directLight(dir_towards_light, oriented_normal, intersection, hitinfo)) {                
                vec4 n = normal;
                vec4 L = dir_towards_light;
                
                // Diffuse
                float kD = 0.8;
                vec4 diffuse = getDiffuse(kD, C, lightIntensity, n, L);

                return ambiant + diffuse;
            } else {
                return ambiant;                
            }
        }
    }

    return vec4(0.8);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5)); 
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates. 
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
