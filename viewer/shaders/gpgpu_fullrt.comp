#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

bool intersectBoundingBox(vec4 origin, vec4 dir) {
	vec3 tmin_tmp = (bbmin - origin.xyz) / dir.xyz;
	vec3 tmax_tmp = (bbmax - origin.xyz) / dir.xyz;
    
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);

    float t_in  = max(max(tmin.x, tmin.y), tmin.z);
    float t_out = min(min(tmax.x, tmax.y), tmax.z);

    return t_out > 0 && t_out > t_in; // t_out > 0 condition to intersect if inside the AABB but not behind it.
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist) 
{
	vec3 v0 = vertices[indices[ptr    ]].xyz;
	vec3 v1 = vertices[indices[ptr + 1]].xyz;
	vec3 v2 = vertices[indices[ptr + 2]].xyz;

    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;

    vec3 t = origin.xyz - v0;
    vec3 q = cross(t, e1);
    vec3 p = cross(dir.xyz, e2);

    vec3 res = (1 / dot(p, e1)) * vec3(dot(q, e2), dot(p, t), dot(q, dir.xyz));

    dist = vec4(res, 1 - res.y - res.z);
    return !(res.x < 0|| (res.y + res.z > 1) || res.y < 0 || res.z < 0); // There is an intersection if the point is inside the triangle and if the intersection is not behind us.
}

vec4 interpolateNormal(hitinfo_t h)
{
	vec4 n1 = normals[indices[h.hit_vptr    ]];
	vec4 n2 = normals[indices[h.hit_vptr + 1]];
	vec4 n3 = normals[indices[h.hit_vptr + 2]];

    float c = h.t.w;
    float alpha = h.t.y;
    float beta = h.t.z;

	return normalize(n1*c + n2*alpha + n3*beta);
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
    return vec4(1);
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
                hit = true;
                if(dist.x < h.t.x) {
                    h.t = dist;
                    h.hit_vptr = j;
                }
			}
		}
	}
	return hit;
}

// Function that return true if the ray intersect with a triangle different from the self triangle.
bool isIntersectedNotSelf(vec4 origin, vec4 dir, int self, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(j != self && intersectTriangle(origin, dir, j, dist)) {
                hit = true;
                if(dist.x < h.t.x) {
                    h.t = dist;
                    h.hit_vptr = j;
                }
			}
		}
	}
	return hit;
}

const int MAX_TRACE = 1;


bool directLight(vec4 origin, vec4 dir, hitinfo_t h) {
    vec4 intersection = origin + h.t.x * dir;
    vec4 dir_towards_light = normalize(vec4(lightPosition, 1.0) - intersection); 
    
    // Normal of the intersected triangle 
    vec4 normal = interpolateNormal(h);
    // Oriented normal depending on the ray direction
    vec4 oriented_normal = normal * sign(dot(-dir, normal));
    
    // If the direction toward the light is behind the hemisphere of the oriented normal then it's not directly illuminated
    // This prevent, for example, the inside of the mesh to be illuminated (particularly visible in the teapot model where light can leak behind the model due to the holes between the lid and the pot (see the hemisphere_fix.png image for visual explanation))
    if (dot(oriented_normal, dir_towards_light) < 0.0) {
        return false;
    }

    hitinfo_t hitinfo_light;
    // Send ray towards light source
    if(isIntersectedNotSelf(intersection, dir_towards_light, h.hit_vptr, hitinfo_light)) {
        // If intersection with a triangle between the point and the light source
        // Then no direct light
        return false;
    } else {
        // If nothing between point and light source, then direct light
        return true;
    }
}

vec4 trace(vec4 origin, vec4 dir)
{
    // If intersection with the bounding box
    if (intersectBoundingBox(origin, dir)) {
        hitinfo_t hitinfo;
        // If intersection with a triangle within the bounding box
        if (isIntersected(origin, dir, hitinfo)) {
            if (directLight(origin, dir, hitinfo)) {
                // Compute full illumination (green)
                return vec4(0, 1, 0, 0);
            } else {
                // Ambiant only (red)
                return vec4(1, 0, 0, 0);                 
            }
        }
    }

    return vec4(0.8);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5)); 
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates. 
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
