#version 430 core
#define PI 3.1415926538

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform float etak; // Imaginary part when eta is complex
uniform bool blinnPhong;

uniform vec4 reflectivity;
uniform vec4 edgetint;
uniform bool is_using_artistic_fresnel;

uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;
uniform bool noColor;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

bool intersectBoundingBox(vec4 origin, vec4 dir) {
	vec3 tmin_tmp = (bbmin - origin.xyz) / dir.xyz;
	vec3 tmax_tmp = (bbmax - origin.xyz) / dir.xyz;
    
    vec3 tmin = min(tmin_tmp, tmax_tmp);
    vec3 tmax = max(tmin_tmp, tmax_tmp);

    float t_in  = max(max(tmin.x, tmin.y), tmin.z);
    float t_out = min(min(tmax.x, tmax.y), tmax.z);

    return t_out > 0 && t_out > t_in; // t_out > 0 condition to intersect if inside the AABB but not behind it.
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist) 
{
	vec3 v0 = vertices[indices[ptr    ]].xyz;
	vec3 v1 = vertices[indices[ptr + 1]].xyz;
	vec3 v2 = vertices[indices[ptr + 2]].xyz;

    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;

    vec3 t = origin.xyz - v0;
    vec3 q = cross(t, e1);
    vec3 p = cross(dir.xyz, e2);

    vec3 res = (1 / dot(p, e1)) * vec3(dot(q, e2), dot(p, t), dot(q, dir.xyz));

    dist = vec4(res, 1 - res.y - res.z);
    return res.x > 0 && res.y >= 0 && res.z >= 0 && res.y+res.z <= 1; // There is an intersection if the point is inside the triangle and if the intersection is in front of us.
}

vec4 interpolateNormal(hitinfo_t h)
{
	vec4 n1 = normals[indices[h.hit_vptr    ]];
	vec4 n2 = normals[indices[h.hit_vptr + 1]];
	vec4 n3 = normals[indices[h.hit_vptr + 2]];

    float c = h.t.w;
    float alpha = h.t.y;
    float beta = h.t.z;

	return normalize(n1*c + n2*alpha + n3*beta);
}

vec4 interpolateColor(hitinfo_t h)
{
	vec4 c1 = colors[indices[h.hit_vptr    ]];
	vec4 c2 = colors[indices[h.hit_vptr + 1]];
	vec4 c3 = colors[indices[h.hit_vptr + 2]];

    float c = h.t.w;
    float alpha = h.t.y;
    float beta = h.t.z;

	return c1*c + c2*alpha + c3*beta;
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
                hit = true;
                if(dist.x < h.t.x) {
                    h.t = dist;
                    h.hit_vptr = j;
                }
			}
		}
	}
	return hit;
}

// Function that return true if the ray intersect with a triangle different from the self triangle.
// For the intersection to be registered, 
// the dot product between the normal of the intersecting face and the direction to the light need to be above an arbitrary threshold (0.2).
// In other words, the intersection is ignored if the normal is too perpendicular to the direction to the light.
// This is an arbitrary trick done to mitigate issues at the transition between direct/indirect light (see leaky_light.png).
// Note that this trick is not a real solution to the problem but, for the tested example, lead to better visual results.
bool isIntersectedNotSelfLeaky(vec4 origin, vec4 dir, int self, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(j != self && intersectTriangle(origin, dir, j, dist)) {
                hitinfo_t tmp;
                tmp.t = dist;
                tmp.hit_vptr = j;
                if (abs(dot(dir, interpolateNormal(tmp))) > 0.2) {
                    hit = true;
                    if(dist.x < h.t.x) {
                        h.t = dist;
                        h.hit_vptr = j;
                    }
                }
			}
		}
	}
	return hit;
}

const int MAX_TRACE = 1;


bool directLight(vec4 dir_towards_light, vec4 oriented_normal, vec4 intersection, hitinfo_t h) {
    
    // If the direction toward the light is behind the hemisphere of the oriented normal then it's not directly illuminated
    // This prevent, for example, the inside of the mesh to be illuminated (particularly visible in the teapot model where light can leak behind the model due to the holes between the lid and the pot (see the hemisphere_fix.png image for visual explanation))
    if (dot(oriented_normal, dir_towards_light) < 0.0) {
        return false;
    }

    hitinfo_t hitinfo_light;
    // Send ray towards light source
    if(isIntersectedNotSelfLeaky(intersection, dir_towards_light, h.hit_vptr, hitinfo_light)) {
        // If intersection with a triangle between the point and the light source
        // Then no direct light
        return false;
    } else {
        // If nothing between point and light source, then direct light
        return true;
    }
}

// ----------------------------------------
// --------------- From TP1 ---------------
// ----------------------------------------
vec4 getAmbiant(float k, vec4 C, float I) {
    return k * C * I;
}

vec4 getDiffuse(float k, vec4 C, float I, vec4 n, vec4 L) {
     return k * C * max(dot(n, L), 0.0) * I;
}

vec3 n_min(vec3 r){
    return (1-r)/(1+r);
}

vec3 n_max(vec3 r){
    return (1+sqrt(r))/(1-sqrt(r)); 
}

vec3 get_n(vec3 r, vec3 g) {
     return n_min(r)*g + (1-g)*n_max(r);
}

vec3 get_k(vec3 r, vec3 n){
    vec3 nr = (n+1)*(n+1)*r-(n-1)*(n-1);
    return sqrt(nr/(1-r));
}

void getEtaForArtisticFresnel(in vec3 reflectivity, in vec3 edgetint, out vec3 eta, out vec3 etak) {
   vec3 _reflectivity = clamp(reflectivity, vec3(0), vec3(0.99));
   eta = get_n(_reflectivity, edgetint);
   etak = get_k(_reflectivity, eta);
}

vec3 fresnel_dieletric_conductor(vec3 eta, vec3 etak, float cosTheta)
{  
   float CosTheta2 = cosTheta * cosTheta;
   float SinTheta2 = 1.0 - CosTheta2;
   vec3 Eta2 = eta * eta;
   vec3 Etak2 = etak * etak;

   vec3 t0 = Eta2 - Etak2 - SinTheta2;
   vec3 a2plusb2 = sqrt(t0 * t0 + 4.0 * Eta2 * Etak2);
   vec3 t1 = a2plusb2 + CosTheta2;
   vec3 a = sqrt(0.5f * (a2plusb2 + t0));
   vec3 t2 = 2 * a * cosTheta;
   vec3 Rs = (t1 - t2) / (t1 + t2);

   vec3 t3 = CosTheta2 * a2plusb2 + SinTheta2 * SinTheta2;
   vec3 t4 = t2 * SinTheta2;   
   vec3 Rp = Rs * (t3 - t4) / (t3 + t4);

   return 0.5 * (Rp + Rs);
}

/*
Return the specular component for Blinn-Phong shading with a fresnel coefficient with a complex eta (a metal).
*/
vec4 getSpecular_EtaComplex_Phong_Fresnel(vec4 C, float I, vec4 n, vec4 L, vec4 V, vec3 eta_in, vec3 eta_out, vec3 etak_out, float exponent) {
    vec3 eta = eta_out / eta_in;
    vec3 etak = etak_out / eta_in;
    
    vec4 H = normalize(V + L);
    vec4 F = vec4(fresnel_dieletric_conductor(eta, etak, dot(H, L)), 1.0);

    return F * C * pow(max(dot(n, H), 0.0), exponent) * I;
}

float chiD(float cosTheta) {
    return step(0.0, cosTheta); // step avoid if statement
}

float D(float cosTheta, float roughness) {
	float cosTheta2 = cosTheta*cosTheta;
	float roughness2 = roughness*roughness;
	return (roughness2*chiD(cosTheta)) / (PI * pow(cosTheta2 * (roughness2 + (1 - cosTheta2)/(cosTheta2)), 2));
}

float G(float cosTheta, float roughness) {
	float cosTheta2 = cosTheta*cosTheta;
	return 2.0 / (1 + sqrt(1 + roughness*roughness*(1 - cosTheta2)/(cosTheta2)));
}

/*
Return the specular component for Cook-Torrance shading with a fresnel coefficient with a triple channel complex eta.
*/
vec4 getSpecular_EtaComplex_CookTorrance(vec4 n, vec4 L, vec4 V, vec3 eta_in, vec3 eta_out, vec3 etak_out, float roughness) {
    vec3 eta = eta_out / eta_in;
    vec3 etak = etak_out / eta_in;     
    
    vec4 H = normalize(V + L);
    vec4 F = vec4(fresnel_dieletric_conductor(eta, etak, dot(H, L)), 1.0);

    float ndotV = dot(n, V);
    float ndotL = dot(n, L);

    float Dh = D(dot(H, n), roughness);
    float G1i = G(ndotV, roughness);
    float G1o = G(ndotL, roughness);

    return max(F * Dh * G1i * G1o / (4 * ndotV * ndotL), 0); // max is here to prevent negative contribution to the final lighting that look odd.
}
// ----------------------------------------

vec4 trace(vec4 origin, vec4 dir)
{
    // If intersection with the bounding box
    if (intersectBoundingBox(origin, dir)) {
        hitinfo_t hitinfo;
        // If intersection with a triangle within the bounding box
        if (isIntersected(origin, dir, hitinfo)) {
            vec4 C;
            if (is_using_artistic_fresnel) {
                C = reflectivity;
            } else if (noColor) {
                C = vec4(0.2, 0.6, 0.7, 1.0);
            } else {
                C = interpolateColor(hitinfo);
            }


            // Ambiant 
            float kA = 0.2;
            vec4 ambiant = getAmbiant(kA, C, lightIntensity);
            
            vec4 intersection = origin + hitinfo.t.x * dir;
            vec4 dir_towards_light = normalize(vec4(lightPosition, 1.0) - intersection); 
    
            // Normal of the intersected triangle 
            vec4 normal = interpolateNormal(hitinfo);
            // Oriented normal depending on the ray direction
            vec4 oriented_normal = normal * sign(dot(-dir, normal));
            
            if (directLight(dir_towards_light, oriented_normal, intersection, hitinfo)) {                
                vec4 n = normal;
                vec4 L = dir_towards_light;
                vec4 V = normalize(mat_inverse*vec4(0, 0, 0, 1) - intersection);

                // Diffuse
                float kD = 0.8;
                vec4 diffuse = getDiffuse(kD, C, lightIntensity, n, L);

                // Specular
                vec3 _eta = vec3(eta);
                vec3 _etak = vec3(etak);
                if (is_using_artistic_fresnel) {
                    getEtaForArtisticFresnel(reflectivity.xyz, edgetint.xyz, _eta, _etak);
                }

                vec4 specular = vec4(0.0);
                if (blinnPhong) {
                    specular = getSpecular_EtaComplex_Phong_Fresnel(C, lightIntensity, n, L, V, vec3(1.0), _eta, _etak, shininess);
                } else {
                    float roughness = (200 - shininess) / 200;
                    specular = C * getSpecular_EtaComplex_CookTorrance(n, L, V, vec3(1.0), _eta, _etak, roughness);
                }
    
                return ambiant + diffuse + specular;
            } else {
                return ambiant;                
            }
        }
    }

    return vec4(0.8);
}

layout (local_size_x = 8, local_size_y = 8) in;

// Note 1 : the output after the "Shadow rays" step of the practical is not exactly the same as the output form TP1 as now we have self-shadowing. Also the nature of the ray-tracing approach lead to more aliasing than the approach from TP1.
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5)); 
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates. 
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
